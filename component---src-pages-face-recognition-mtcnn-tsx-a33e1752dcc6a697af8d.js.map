{"version":3,"sources":["webpack:///./src/components/AdjustableInput.tsx?a801","webpack:///./src/components/DisplayFullFaceDescriptions.tsx?c963","webpack:///./src/components/MtcnnParamControls.tsx?08e8","webpack:///./src/facc/AllFacesMtcnn.tsx","webpack:///./src/facc/ComputeRefDescriptors.tsx?f8f0","webpack:///./src/hoc/withAllFaces.tsx?cc82","webpack:///./src/pages/face_recognition_mtcnn.tsx"],"names":[],"mappings":"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","file":"component---src-pages-face-recognition-mtcnn-tsx-a33e1752dcc6a697af8d.js","sourcesContent":["import { Button, FormControl, Input, InputLabel } from '@material-ui/core';\r\nimport * as React from 'react';\r\nimport styled from 'styled-components';\r\nimport { SideBySide } from '../styled/SideBySide';\r\n\r\nexport const StyledFormControl = styled(FormControl)`\r\n  margin: 10px !important;\r\n`\r\n\r\nexport const StyledButton = styled(Button)`\r\n  width: 40px;\r\n  height: 40px;\r\n`\r\n\r\nexport type AdjustableInputProps = {\r\n  inputId: string\r\n  label: string\r\n  value: number\r\n  minValue: number\r\n  maxValue: number\r\n  step: number\r\n  onChange: (newValue: number) => any\r\n}\r\n\r\nexport const AdjustableInput = (props: AdjustableInputProps) =>\r\n  <StyledFormControl>\r\n    <SideBySide>\r\n      <InputLabel htmlFor={props.inputId}>\r\n        { props.label }\r\n      </InputLabel>\r\n      <Input\r\n        id={props.inputId}\r\n        value={props.value}\r\n      />\r\n      <StyledButton\r\n        variant=\"outlined\"\r\n        onClick={\r\n          () => props.onChange(Math.max(props.value - props.step, props.minValue))\r\n        }\r\n      >\r\n        -\r\n      </StyledButton>\r\n      <StyledButton\r\n        variant=\"outlined\"\r\n        onClick={\r\n          () => props.onChange(Math.min(props.value + props.step, props.maxValue))\r\n        }\r\n      >\r\n        +\r\n      </StyledButton>\r\n    </SideBySide>\r\n  </StyledFormControl>\n\n\n// WEBPACK FOOTER //\n// ./src/components/AdjustableInput.tsx","import * as faceapi from 'face-api.js';\r\nimport * as React from 'react';\r\n\r\nimport { BestMatch } from '../facc/ComputeRefDescriptors';\r\nimport { DisplayResults } from './DisplayResults';\r\n\r\n\r\nexport interface DisplayFullFaceDescriptionsProps {\r\n  fullFaceDescriptions: faceapi.FullFaceDescription[]\r\n  overlay: HTMLCanvasElement\r\n  getBestMatch: (queryDescriptor: Float32Array) => BestMatch\r\n  withScore?: boolean\r\n  drawLandmarks?: boolean\r\n}\r\n\r\nexport const DisplayFullFaceDescriptions = (props: DisplayFullFaceDescriptionsProps): any => {\r\n\r\n  const { fullFaceDescriptions, overlay, withScore, drawLandmarks, getBestMatch } = props\r\n\r\n  const faceDetections = fullFaceDescriptions.map(fd => fd.detection)\r\n  const faceLandmarks = drawLandmarks\r\n    ? fullFaceDescriptions.map(fd => fd.landmarks)\r\n    : []\r\n  const bestMatches = fullFaceDescriptions.map(fd => getBestMatch(fd.descriptor))\r\n\r\n  const displayResultsProps = {\r\n    overlay,\r\n    withScore,\r\n    faceDetections,\r\n    faceLandmarks,\r\n    bestMatches\r\n  }\r\n\r\n  return <DisplayResults {...displayResultsProps} />\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/components/DisplayFullFaceDescriptions.tsx","import * as React from 'react';\r\n\r\nimport { MtcnnForwardParams } from '../../node_modules/face-api.js/build/mtcnn/types';\r\nimport { CenterContent } from '../styled/CenterContent';\r\nimport { AdjustableInput } from './AdjustableInput';\r\n\r\nexport interface MtcnnParamControlsProps {\r\n  detectionParams: MtcnnForwardParams\r\n  onChange: (detectionParams: MtcnnForwardParams) => any\r\n}\r\n\r\nexport const MtcnnParamControls = (props: MtcnnParamControlsProps) =>\r\n  <CenterContent flexDirection=\"column\">\r\n    <AdjustableInput\r\n      inputId=\"scaleFactor\"\r\n      label=\"scaleFactor:\"\r\n      value={props.detectionParams.scaleFactor}\r\n      minValue={0.1}\r\n      maxValue={0.9}\r\n      step={0.05}\r\n      onChange={\r\n        (scaleFactor: number) => props.onChange({ ...props.detectionParams, scaleFactor })\r\n      }\r\n    />\r\n    <AdjustableInput\r\n      inputId=\"minFaceSize\"\r\n      label=\"minFaceSize:\"\r\n      value={props.detectionParams.minFaceSize}\r\n      minValue={40}\r\n      maxValue={400}\r\n      step={40}\r\n      onChange={\r\n        (minFaceSize: number) => props.onChange({ ...props.detectionParams, minFaceSize })\r\n      }\r\n    />\r\n  </CenterContent>\n\n\n// WEBPACK FOOTER //\n// ./src/components/MtcnnParamControls.tsx","import * as faceapi from 'face-api.js';\n\nimport { MtcnnForwardParams } from '../../node_modules/face-api.js/build/mtcnn/types';\nimport { withAllFaces } from '../hoc/withAllFaces';\n\n// TODO: export faceapi.MtcnnForwardParams\nexport type DetectionParams = MtcnnForwardParams\n\nexport const AllFacesMtcnn = withAllFaces<DetectionParams>(\n  (img: HTMLImageElement, detectionParams: DetectionParams) => faceapi.allFacesMtcnn(img, detectionParams)\n)\n\n\n\n// WEBPACK FOOTER //\n// ./src/facc/AllFacesMtcnn.tsx","import * as faceapi from 'face-api.js';\nimport * as React from 'react';\n\nimport { ModalLoader } from '../components/ModalLoader';\nimport { withAsyncRendering } from '../hoc/withAsyncRendering';\n\nexport type RefDescriptor = {\n  label: string,\n  descriptor: Float32Array\n}\n\nexport type BestMatch = {\n  label: string,\n  distance: number\n}\n\nexport interface ComputeRefDescriptorsProps {\n  faceRecognitionNet: faceapi.FaceRecognitionNet\n  refDataSources: {\n    label: string,\n    url: string\n  }[]\n}\n\nexport interface ComputeRefDescriptorsState {\n  refDescriptors?: RefDescriptor[]\n  getBestMatch?: (queryDescriptor: Float32Array) => BestMatch\n}\n\nasync function initRefDescriptors(props: ComputeRefDescriptorsProps) {\n  const refDescriptors = await Promise.all(\n    props.refDataSources.map(async ({ label, url }) => {\n      const img = await faceapi.bufferToImage(await (await fetch(url)).blob())\n      const descriptor = await props.faceRecognitionNet.computeFaceDescriptor(img) as Float32Array\n      return {\n        label: label.replace('1.png', ''),\n        descriptor\n      }\n    })\n  )\n\n  const getBestMatch = (queryDescriptor: Float32Array) =>\n    refDescriptors.map(ref => ({\n      label: ref.label,\n      distance: faceapi.euclideanDistance(ref.descriptor, queryDescriptor)\n    }))\n      .reduce((best, curr) => curr.distance < best.distance ? curr : best)\n\n  return {\n    refDescriptors,\n    getBestMatch\n  }\n}\n\nexport const ComputeRefDescriptors = withAsyncRendering<ComputeRefDescriptorsProps, ComputeRefDescriptorsState>(\n  initRefDescriptors,\n  () => <ModalLoader title=\"Computing Reference Descriptors\"/>\n)\n\n\n\n// WEBPACK FOOTER //\n// ./src/facc/ComputeRefDescriptors.tsx","import * as faceapi from 'face-api.js';\n\nimport { ImageWrap } from '../ImageWrap';\nimport { withAsyncRendering } from './withAsyncRendering';\nimport { ModalLoader } from '../components/ModalLoader';\nimport * as React from 'react';\n\nexport interface WithAllFacesProps {\n  img: ImageWrap\n}\n\nexport interface WithAllFacesState {\n  fullFaceDescriptions?: faceapi.FullFaceDescription[]\n}\n\ntype Props<DetectionParams> = WithAllFacesProps & {\n  detectionParams: DetectionParams\n}\n\nexport const withAllFaces = <DetectionParams extends {}> (\n  allFacesFunction: (img: HTMLImageElement | HTMLCanvasElement, params: DetectionParams) => Promise<faceapi.FullFaceDescription[]>\n) => {\n  async function allFaces(props: Props<DetectionParams>) {\n    const fullFaceDescriptions = await allFacesFunction(props.img.img, props.detectionParams)\n\n    return {\n      fullFaceDescriptions\n    }\n  }\n\n  return withAsyncRendering<Props<DetectionParams>, WithAllFacesState>(\n    allFaces,\n    () => <ModalLoader title=\"Detecting Faces\"/>\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hoc/withAllFaces.tsx","import * as React from 'react';\n\nimport { MtcnnForwardParams } from '../../node_modules/face-api.js/build/mtcnn/types';\nimport { DisplayFullFaceDescriptions } from '../components/DisplayFullFaceDescriptions';\nimport { ModalLoader } from '../components/ModalLoader';\nimport { MtcnnParamControls } from '../components/MtcnnParamControls';\nimport { SelectableImage } from '../components/SelectableImage';\nimport { ALIGNED_FACE_IMAGES_BY_CLASS, EXAMPLE_IMAGES } from '../const';\nimport { AllFacesMtcnn } from '../facc/AllFacesMtcnn';\nimport { ComputeRefDescriptors } from '../facc/ComputeRefDescriptors';\nimport { LoadModels } from '../facc/LoadModels';\nimport { ImageWrap } from '../ImageWrap';\nimport { Root } from '../Root';\n\ntype FaceRecognitionMtcnnPageState = {\n  inputImg: ImageWrap\n  detectionParams: MtcnnForwardParams\n  overlay?: HTMLCanvasElement\n}\n\nconst REF_DATA_SOURCES = ALIGNED_FACE_IMAGES_BY_CLASS.map(srcsByClass => srcsByClass[0])\n\nexport default class extends React.Component<{}, FaceRecognitionMtcnnPageState> {\n\n  state: FaceRecognitionMtcnnPageState = {\n    inputImg: new ImageWrap(EXAMPLE_IMAGES[0].url),\n    detectionParams: {\n      minFaceSize: 40,\n      scaleFactor: 0.7\n    }\n  }\n\n  public render() {\n    if (!(typeof window !== 'undefined' && window.document) ){\n      return null\n    }\n\n    return(\n      <Root>\n        <SelectableImage\n          items={EXAMPLE_IMAGES}\n          initialImageSrc={this.state.inputImg.imageSrc}\n          onLoaded={({ img: inputImg, overlay }) => this.setState({ inputImg, overlay })}\n          maxImageWidth={800}\n        />\n        <MtcnnParamControls\n          detectionParams={this.state.detectionParams}\n          onChange={detectionParams => this.setState({ detectionParams })}\n        />\n        <LoadModels\n          mtcnnModelUrl={MODELS_URI}\n          faceRecognitionModelUrl={MODELS_URI}\n        >\n        {\n          ({ faceRecognitionNet }) =>\n            <ComputeRefDescriptors\n              faceRecognitionNet={faceRecognitionNet}\n              refDataSources={REF_DATA_SOURCES}\n            >\n            {\n            ({ getBestMatch }) =>\n                <AllFacesMtcnn\n                  img={this.state.inputImg}\n                  detectionParams={this.state.detectionParams}\n                >\n                {\n                  ({ fullFaceDescriptions, isBusy }) =>\n                    isBusy\n                      ? <ModalLoader title=\"Computing\"/>\n                      :\n                        <DisplayFullFaceDescriptions\n                          fullFaceDescriptions={fullFaceDescriptions}\n                          overlay={this.state.overlay}\n                          getBestMatch={getBestMatch}\n                          drawLandmarks\n                        />\n                }\n                </AllFacesMtcnn>\n            }\n            </ComputeRefDescriptors>\n        }\n        </LoadModels>\n      </Root>\n    )\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/face_recognition_mtcnn.tsx"],"sourceRoot":""}